package istio

import (
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	core "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
	discovery "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
	"github.com/google/uuid"
	uberatomic "go.uber.org/atomic"
	"google.golang.org/grpc"
	"google.golang.org/grpc/peer"
	"istio.io/istio/pilot/pkg/util/protoconv"
	"istio.io/istio/pkg/model"
	"istio.io/istio/pkg/util/sets"
	"istio.io/istio/pkg/xds"
)

type xdsServer struct {
	collections map[string]any
	stop        chan struct{}

	clientsMu sync.Mutex
	clients   map[string]*Context
}

func (s *xdsServer) StreamAggregatedResources(server discovery.AggregatedDiscoveryService_StreamAggregatedResourcesServer) error {
	//TODO implement me
	panic("implement me")
}

func (s *xdsServer) DeltaAggregatedResources(stream discovery.AggregatedDiscoveryService_DeltaAggregatedResourcesServer) error {
	ctx := stream.Context()
	peerAddr := "0.0.0.0"
	if peerInfo, ok := peer.FromContext(ctx); ok {
		peerAddr = peerInfo.Addr.String()
	}
	return xds.Stream(&Context{
		BaseConnection: xds.NewConnection(peerAddr, nil),
		s:              s,
		w:              &Watch{},
	})
}

type Context struct {
	BaseConnection xds.Connection
	s              *xdsServer
	w              *Watch
}

type Watch struct {
	sync.Mutex
	watch *xds.WatchedResource
	ID    string
}

// new creates Secret Discovery Service which implements envoy SDS API.
func new() *xdsServer {
	ret := &xdsServer{
		stop:    make(chan struct{}),
		clients: make(map[string]*Context),
	}

	return ret
}

var version uberatomic.Uint64

func (s *xdsServer) generate(resourceNames []string) (*discovery.DiscoveryResponse, error) {
	resources := xds.Resources{}
	for _, resourceName := range resourceNames {
		secret, err := s.st.GenerateSecret(resourceName)
		if err != nil {
			// Typically, in Istiod, we do not return an error for a failure to generate a resource
			// However, here it makes sense, because we are generally streaming a single resource,
			// so sending an error will not cause a single failure to prevent the entire multiplex stream
			// of resources, and failures here are generally due to temporary networking issues to the CA
			// rather than a result of configuration issues, which trigger updates in Istiod when resolved.
			// Instead, we rely on the client to retry (with backoff) on failures.
			return nil, fmt.Errorf("failed to generate secret for %v: %v", resourceName, err)
		}

		res := protoconv.MessageToAny(toEnvoySecret(secret, s.rootCaPath, s.pkpConf))
		resources = append(resources, &discovery.Resource{
			Name:     resourceName,
			Resource: res,
		})
	}
	return &discovery.DiscoveryResponse{
		TypeUrl:     model.SecretType,
		VersionInfo: time.Now().Format(time.RFC3339) + "/" + strconv.FormatUint(version.Inc(), 10),
		Nonce:       uuid.New().String(),
		Resources:   xds.ResourcesToAny(resources),
	}, nil
}

// register adds the SDS handle to the grpc server
func (s *xdsServer) register(rpcs *grpc.Server) {
	discovery.RegisterAggregatedDiscoveryServiceServer(rpcs, s)
}

func (s *xdsServer) push(secretName string) {
	s.clientsMu.Lock()
	defer s.clientsMu.Unlock()
	for _, client := range s.clients {
		go func(client *Context) {
			select {
			case client.XdsConnection().PushCh() <- secretName:
			case <-client.XdsConnection().StreamDone():
			}
		}(client)
	}
}

func (c *Context) XdsConnection() *xds.Connection {
	return &c.BaseConnection
}

var connectionNumber = int64(0)

func (c *Context) Initialize(_ *core.Node) error {
	id := atomic.AddInt64(&connectionNumber, 1)
	con := c.XdsConnection()
	con.SetID(strconv.FormatInt(id, 10))

	c.s.clientsMu.Lock()
	c.s.clients[con.ID()] = c
	c.s.clientsMu.Unlock()

	con.MarkInitialized()
	return nil
}

func (c *Context) Close() {
	c.s.clientsMu.Lock()
	defer c.s.clientsMu.Unlock()
	delete(c.s.clients, c.XdsConnection().ID())
}

func (c *Context) Watcher() xds.Watcher {
	return c.w
}

func (w *Watch) DeleteWatchedResource(string) {
	w.Lock()
	defer w.Unlock()
	w.watch = nil
}

func (w *Watch) GetWatchedResource(string) *xds.WatchedResource {
	w.Lock()
	defer w.Unlock()
	return w.watch
}

func (w *Watch) NewWatchedResource(typeURL string, names []string) {
	w.Lock()
	defer w.Unlock()
	w.watch = &xds.WatchedResource{TypeUrl: typeURL, ResourceNames: sets.New(names...)}
}

func (w *Watch) UpdateWatchedResource(_ string, f func(*xds.WatchedResource) *xds.WatchedResource) {
	w.Lock()
	defer w.Unlock()
	w.watch = f(w.watch)
}

func (w *Watch) GetID() string {
	// This always maps to the same local Envoy instance.
	return ""
}

func (w *Watch) requested(secretName string) bool {
	w.Lock()
	defer w.Unlock()
	if w.watch != nil {
		return w.watch.ResourceNames.Contains(secretName)
	}
	return false
}

func (c *Context) Process(req *discovery.DeltaDiscoveryRequest) error {
	shouldRespond, delta := xds.ShouldRespond(c.Watcher(), c.XdsConnection().ID(), req)
	if !shouldRespond {
		return nil
	}
	resources := req.ResourceNames
	if !delta.IsEmpty() {
		resources = delta.Subscribed.UnsortedList()
	}
	res, err := c.s.generate(resources)
	if err != nil {
		return err
	}
	return xds.Send(c, res)
}

func (c *Context) Push(ev any) error {
	secretName := ev.(string)
	if !c.w.requested(secretName) {
		return nil
	}
	res, err := c.s.generate([]string{secretName})
	if err != nil {
		return err
	}
	return xds.Send(c, res)
}

func (s *xdsServer) Close() {
	close(s.stop)
}
